<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="generator" content="Asciidoctor 2.0.10">
<title>198. House Robber</title>
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:300,300italic,400,400italic,600,600italic%7CNoto+Serif:400,400italic,700,700italic%7CDroid+Sans+Mono:400,700">
<link rel="stylesheet" href="assets/css/asciidoctor.css">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">
</head>
<body class="book toc2 toc-left">
<div id="header">
<div id="toc" class="toc2">
<div id="toctitle">Table of Contents</div>
<ul class="sectlevel1">
<li><a href="#_198_house_robber">198. House Robber</a></li>
</ul>
</div>
</div>
<div id="content">
<div class="sect1">
<h2 id="_198_house_robber"><a class="anchor" href="#_198_house_robber"></a>198. House Robber</h2>
<div class="sectionbody">
<div class="paragraph">
<p><a href="https://leetcode.com/problems/house-robber/">LeetCode - House Robber</a></p>
</div>
<div class="paragraph">
<p>假设 f(k) = 从前 k 个房屋中能抢劫到的最大数额，A<sub>i</sub> = 第 i 个房屋的钱数。</p>
</div>
<div class="paragraph">
<p>当 n=1 时，显然 f(1) = A<sub>1</sub>。</p>
</div>
<div class="paragraph">
<p>当 n=2 时，f(2) = max(A<sub>1</sub>, A<sub>2</sub>)。</p>
</div>
<div class="paragraph">
<p>当 n=3 时，有两种选项：</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>将第三个房间金额和第一个房间金额相加；</p>
</li>
<li>
<p>不算第三个房间，保持当前最大金额。</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>于是，可以总结出公式: \(f(k)=\max \left(f(k-2)+A_{k}, f(k-1)\right)\)。</p>
</div>
<div class="paragraph">
<p>剩下的工作就好办了。</p>
</div>
<div class="paragraph">
<p>让 D瓜哥 使用 <a href="https://www.diguage.com/post/dynamic-programming/">动态规划的模式</a> 来重新解读一下：</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>刻画一个最优解的结构特征：求解抢劫金额最大值。</p>
</li>
<li>
<p>递归地定义最优解的值： \(f(k)=\max \left(f(k-2)+A_{k}, f(k-1)\right)\)。</p>
</li>
<li>
<p>计算最优解的值，通常采用自底向上的方法：D瓜哥也按照动态规划（注意表格）的方式来实现，采用自底向上+备忘录的方式来求解，创建一个长度为 n+1 的数组，第 i 个元素表示到第 i 个房间为止，最大抢劫金额；则第 0 个元素为 0，第 1 个元素为 A<sub>1</sub>。然后根据上述公式定义，以此类推……</p>
</li>
<li>
<p>利用计算出的信息构造一个最优解。这一步不需要，暂时忽略。</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>使用递归、递归+备忘录、自底向上+备忘录，自底向上+简化备忘录四种方式分别实现。</p>
</div>
<div class="paragraph">
<p>You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed, the only constraint stopping you from robbing each of them is that adjacent houses have security system connected and <strong>it will automatically contact the police if two adjacent houses were broken into on the same night</strong>.</p>
</div>
<div class="paragraph">
<p>Given a list of non-negative integers representing the amount of money of each house, determine the maximum amount of money you can rob tonight <strong>without alerting the police</strong>.</p>
</div>
<div class="paragraph">
<p><strong>Example 1:</strong></p>
</div>
<div class="listingblock">
<div class="content">
<pre><strong>Input:</strong> [1,2,3,1]
<strong>Output:</strong> 4
<strong>Explanation:</strong> Rob house 1 (money = 1) and then rob house 3 (money = 3).
             Total amount you can rob = 1 + 3 = 4.</pre>
</div>
</div>
<div class="paragraph">
<p><strong>Example 2:</strong></p>
</div>
<div class="listingblock">
<div class="content">
<pre><strong>Input:</strong> [2,7,9,3,1]
<strong>Output:</strong> 12
<strong>Explanation:</strong> Rob house 1 (money = 2), rob house 3 (money = 9) and rob house 5 (money = 1).
             Total amount you can rob = 2 + 9 + 1 = 12.</pre>
</div>
</div>
<div id="src-0198" class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-{java_source_attr}" data-lang="{java_source_attr}">package com.diguage.algorithm.leetcode;

import java.util.Arrays;
import java.util.Objects;

/**
 * = 198. House Robber
 *
 * https://leetcode.com/problems/house-robber/[House Robber - LeetCode]
 *
 * You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed, the only constraint stopping you from robbing each of them is that adjacent houses have security system connected and *it will automatically contact the police if two adjacent houses were broken into on the same night.*
 *
 * Given a list of non-negative integers representing the amount of money of each house, determine the maximum amount of money you can rob tonight *without alerting the police.*
 *
 * .Example 1:
 * [source]
 * ----
 * Input: [1,2,3,1]
 * Output: 4
 * Explanation: Rob house 1 (money = 1) and then rob house 3 (money = 3).
 *              Total amount you can rob = 1 + 3 = 4.
 * ----
 *
 * .Example 2:
 * [source]
 * ----
 * Input: [2,7,9,3,1]
 * Output: 12
 * Explanation: Rob house 1 (money = 2), rob house 3 (money = 9) and rob house 5 (money = 1).
 *              Total amount you can rob = 2 + 9 + 1 = 12.
 * ----
 *
 * @author D瓜哥, https://www.diguage.com/
 * @since 2020-01-23 22:37
 */
public class _0198_HouseRobber {

    /**
     * Runtime: 0 ms, faster than 100.00% of Java online submissions for House Robber.
     *
     * Memory Usage: 41.2 MB, less than 5.26% of Java online submissions for House Robber.
     */
    public int rob(int[] nums) {
        int k2 = 0;
        int k1 = 0;
        for (int num : nums) {
            int current = Math.max(k2 + num, k1);
            k2 = k1;
            k1 = current;
        }
        return k1;
    }

    /**
     * Runtime: 1 ms, faster than 5.81% of Java online submissions for House Robber.
     *
     * Memory Usage: 41.9 MB, less than 5.26% of Java online submissions for House Robber.
     */
    public int robDP(int[] nums) {
        if (Objects.isNull(nums) || nums.length == 0) {
            return 0;
        }
        int[] memo = new int[nums.length + 1];
        memo[0] = 0;
        memo[1] = nums[0];
        for (int i = 2; i &lt; memo.length; i++) {
            int max = Math.max(memo[i - 2] + nums[i - 1], memo[i - 1]);
            memo[i] = max;
        }
        return memo[nums.length];
    }

    /**
     * Runtime: 1 ms, faster than 5.81% of Java online submissions for House Robber.
     *
     * Memory Usage: 41.3 MB, less than 5.26% of Java online submissions for House Robber.
     */
    public int robRecursionWithMemo(int[] nums) {
        if (Objects.isNull(nums) || nums.length == 0) {
            return 0;
        }
        int[] memo = new int[nums.length];
        Arrays.fill(memo, Integer.MIN_VALUE);
        memo[0] = nums[0];
        rob(nums, memo, nums.length - 1);
        return memo[nums.length - 1];
    }

    private int rob(int[] nums, int[] memo, int k) {
        if (k == -2 || k == -1) {
            return 0;
        }

        int rob2 = 0;
        if (k - 2 &gt;= 0 &amp;&amp; memo[k - 2] &gt;= 0) {
            rob2 = memo[k - 2];
        } else {
            rob2 = rob(nums, memo, k - 2);
        }
        int rob1 = 0;
        if (k - 1 &gt;= 0 &amp;&amp; memo[k - 1] &gt;= 0) {
            rob1 = memo[k - 1];
        } else {
            rob1 = rob(nums, memo, k - 1);
        }
        int rob0 = Math.max(rob2 + nums[k], rob1);
        memo[k] = rob0;
        return rob0;
    }


    // -----
    public int robRecursion(int[] nums) {
        return rob(nums, nums.length - 1);
    }

    private int rob(int[] nums, int k) {
        if (k == -2 || k == -1) {
            return 0;
        }
        return Math.max(rob(nums, k - 2) + nums[k], rob(nums, k - 1));
    }

    public static void main(String[] args) {
        _0198_HouseRobber solution = new _0198_HouseRobber();
        int[] n1 = {1, 2, 3, 1};
        int r1 = solution.rob(n1);
        System.out.println((r1 == 4) + " : " + r1);

        int[] n2 = {2, 7, 9, 3, 1};
        int r2 = solution.rob(n2);
        System.out.println((r2 == 12) + " : " + r2);
    }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
<div id="footer">
<div id="footer-text">
Last updated 2020-02-13 11:39:08 +0800
</div>
</div>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  messageStyle: "none",
  tex2jax: {
    inlineMath: [["\\(", "\\)"]],
    displayMath: [["\\[", "\\]"]],
    ignoreClass: "nostem|nolatexmath"
  },
  asciimath2jax: {
    delimiters: [["\\$", "\\$"]],
    ignoreClass: "nostem|noasciimath"
  },
  TeX: { equationNumbers: { autoNumber: "none" } }
})
MathJax.Hub.Register.StartupHook("AsciiMath Jax Ready", function () {
  MathJax.InputJax.AsciiMath.postfilterHooks.Add(function (data, node) {
    if ((node = data.script.parentNode) && (node = node.parentNode) && node.classList.contains('stemblock')) {
      data.math.root.display = "block"
    }
    return data
  })
})
</script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_HTMLorMML"></script>
</body>
</html>