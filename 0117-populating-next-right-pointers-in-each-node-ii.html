<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="generator" content="Asciidoctor 2.0.10">
<title>117. Populating Next Right Pointers in Each Node II</title>
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:300,300italic,400,400italic,600,600italic%7CNoto+Serif:400,400italic,700,700italic%7CDroid+Sans+Mono:400,700">
<link rel="stylesheet" href="assets/css/asciidoctor.css">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">
</head>
<body class="book toc2 toc-left">
<div id="header">
<div id="toc" class="toc2">
<div id="toctitle">Table of Contents</div>
<ul class="sectlevel1">
<li><a href="#_117_populating_next_right_pointers_in_each_node_ii">117. Populating Next Right Pointers in Each Node II</a>
<ul class="sectlevel2">
<li><a href="#_解题分析">解题分析</a></li>
<li><a href="#_参考资料">参考资料</a></li>
</ul>
</li>
</ul>
</div>
</div>
<div id="content">
<div class="sect1">
<h2 id="_117_populating_next_right_pointers_in_each_node_ii"><a class="anchor" href="#_117_populating_next_right_pointers_in_each_node_ii"></a>117. Populating Next Right Pointers in Each Node II</h2>
<div class="sectionbody">
<div class="paragraph">
<p><a href="https://leetcode.com/problems/populating-next-right-pointers-in-each-node-ii/">LeetCode - Populating Next Right Pointers in Each Node II</a></p>
</div>
<div class="paragraph">
<p>Given a binary tree</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">struct Node {
  int val;
  Node *left;
  Node *right;
  Node *next;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Populate each next pointer to point to its next right node. If there is no next right node, the next pointer should be set to <code>NULL</code>.</p>
</div>
<div class="paragraph">
<p>Initially, all next pointers are set to <code>NULL</code>.</p>
</div>
<div class="paragraph">
<p><strong>Follow up:</strong></p>
</div>
<div class="ulist">
<ul>
<li>
<p>You may only use constant extra space.</p>
</li>
<li>
<p>Recursive approach is fine, you may assume implicit stack space does not count as extra space for this problem.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><strong>Example 1:</strong></p>
</div>
<div class="imageblock">
<div class="content">
<img src="./images/0117-1.png" alt="0117 1">
</div>
</div>
<div class="listingblock">
<div class="content">
<pre><strong>Input:</strong> root = [1,2,3,4,5,null,7]
<strong>Output:</strong> [1,<mark>,2,3,</mark>,4,5,7,<mark>]
<strong>Explanation:</strong> Given the above binary tree (Figure A), your function should populate each next pointer to point to its next right node, just like in Figure B. The serialized output is in level order as connected by the next pointers, with '</mark>' signifying the end of each level.</pre>
</div>
</div>
<div class="paragraph">
<p><strong>Constraints:</strong></p>
</div>
<div class="ulist">
<ul>
<li>
<p>The number of nodes in the given tree is less than <code>6000</code>.</p>
</li>
<li>
<p><code>-100 &#8656; node.val &#8656; 100</code></p>
</li>
</ul>
</div>
<div class="sect2">
<h3 id="_解题分析"><a class="anchor" href="#_解题分析"></a>解题分析</h3>
<div class="paragraph">
<p>这道题和 <a href="0116-populating-next-right-pointers-in-each-node.html">116. Populating Next Right Pointers in Each Node</a> 算是姊妹题。</p>
</div>
<div class="paragraph">
<p>最简单的方式，使用 <code>Deque</code> 来保存每一层节点，然后建立起来"连接"。但是，很明显，这种方案不符合空间复杂度要求。</p>
</div>
<div class="paragraph">
<p>基于上面这种解法，再深入思考一步，上面使用 <code>Deque</code> 就是想要保存接下来需要访问的元素，并且保存访问的前后顺序。现在 <code>Node</code> 上有 <code>next</code> 字段，可以利用这个字段，打通这条链表，遍历上一层时，打通下一次的链接结构。这里需要保存的就有两点：</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>这条链表的头结点，用于下一层的遍历；</p>
</li>
<li>
<p>这条链表的尾节点，用于添加下一个节点。</p>
</li>
</ol>
</div>
<div class="imageblock">
<div class="content">
<img src="./images/0117-2.jpg" alt="0117 2">
</div>
</div>
<div class="paragraph">
<p>这样，把第一种解法的代码稍作修改就可以了。</p>
</div>
</div>
<div class="sect2">
<h3 id="_参考资料"><a class="anchor" href="#_参考资料"></a>参考资料</h3>
<div class="olist arabic">
<ol class="arabic">
<li>
<p><a href="https://leetcode-cn.com/problems/populating-next-right-pointers-in-each-node-ii/solution/xiang-xi-tong-su-de-si-lu-fen-xi-duo-jie-fa-by-28/">详细通俗的思路分析，多解法 - 填充每个节点的下一个右侧节点指针 II - 力扣（LeetCode）</a></p>
</li>
<li>
<p><a href="https://leetcode.wang/leetcode-117-Populating-Next-Right-Pointers-in-Each-NodeII.html">117. Populating Next Right Pointers in Each Node II · leetcode</a></p>
</li>
</ol>
</div>
<div id="src-0117" class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-{java_source_attr}" data-lang="{java_source_attr}">package com.diguage.algorithm.leetcode;

import com.diguage.algorithm.util.TreeNode;

import java.util.Deque;
import java.util.LinkedList;
import java.util.Objects;

import static com.diguage.algorithm.util.TreeNodeUtils.buildTree;
import static java.util.Arrays.asList;

/**
 * @author D瓜哥, https://www.diguage.com/
 * @since 2020-02-09 23:17
 */
public class _0117_PopulatingNextRightPointersInEachNodeII {

    static class Node {
        public int val;
        public Node left;
        public Node right;
        public Node next;

        public Node(int x) {
            this.val = x;
        }

        @Override
        public String toString() {
            return "Node{" +
                    "val=" + val +
                    ", left=" + left +
                    ", right=" + right +
                    '}';
        }
    }


    /**
     * Runtime: 1 ms, faster than 49.14% of Java online submissions for Populating Next Right Pointers in Each Node II.
     * Memory Usage: 41.4 MB, less than 100.00% of Java online submissions for Populating Next Right Pointers in Each Node II.
     *
     * Copy from: https://leetcode-cn.com/problems/populating-next-right-pointers-in-each-node-ii/solution/xiang-xi-tong-su-de-si-lu-fen-xi-duo-jie-fa-by-28/[详细通俗的思路分析，多解法 - 填充每个节点的下一个右侧节点指针 II - 力扣（LeetCode）]
     */
    public Node connect(Node root) {
        Node curr = root;
        while (Objects.nonNull(curr)) {
            Node dummy = new Node(0);
            Node tail = dummy;
            while (Objects.nonNull(curr)) {
                if (Objects.nonNull(curr.left)) {
                    tail.next = curr.left;
                    tail = tail.next;
                }
                if (Objects.nonNull(curr.right)) {
                    tail.next = curr.right;
                    tail = tail.next;
                }
                curr = curr.next;
            }
            curr = dummy.next;
        }
        return root;
    }

    /**
     * Runtime: 1 ms, faster than 49.14% of Java online submissions for Populating Next Right Pointers in Each Node II.
     * Memory Usage: 40.8 MB, less than 100.00% of Java online submissions for Populating Next Right Pointers in Each Node II.
     */
    public Node connectDeque(Node root) {
        if (Objects.isNull(root)) {
            return null;
        }
        Deque&lt;Node&gt; deque = new LinkedList&lt;&gt;();
        deque.addLast(root);
        Node prev = null;
        while (!deque.isEmpty()) {
            int size = deque.size();
            for (int i = 0; i &lt; size; i++) {
                Node curr = deque.removeFirst();
                if (Objects.nonNull(curr.left)) {
                    deque.addLast(curr.left);
                }
                if (Objects.nonNull(curr.right)) {
                    deque.addLast(curr.right);
                }
                if (i &gt; 0) {
                    prev.next = curr;
                }
                prev = curr;
            }
        }
        return root;
    }

    public static void main(String[] args) {
        _0117_PopulatingNextRightPointersInEachNodeII solution = new _0117_PopulatingNextRightPointersInEachNodeII();
        TreeNode treeNode = buildTree(asList(1, 2, 3, 4, 5, null, 7));
        Node node = convert(treeNode);
        Node r1 = solution.connect(node);
        System.out.println(r1);
    }

    private static Node convert(TreeNode treeNode) {
        if (Objects.isNull(treeNode)) {
            return null;
        }
        Node node = new Node(treeNode.val);
        node.left = convert(treeNode.left);
        node.right = convert(treeNode.right);
        return node;
    }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div id="footer">
<div id="footer-text">
Last updated 2020-02-13 11:39:08 +0800
</div>
</div>
</body>
</html>