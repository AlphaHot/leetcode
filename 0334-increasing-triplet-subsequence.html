<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="generator" content="Asciidoctor 2.0.10">
<title>334. Increasing Triplet Subsequence</title>
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:300,300italic,400,400italic,600,600italic%7CNoto+Serif:400,400italic,700,700italic%7CDroid+Sans+Mono:400,700">
<link rel="stylesheet" href="assets/css/asciidoctor.css">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">
</head>
<body class="book toc2 toc-left">
<div id="header">
<div id="toc" class="toc2">
<div id="toctitle">Table of Contents</div>
<ul class="sectlevel1">
<li><a href="#_334_increasing_triplet_subsequence">334. Increasing Triplet Subsequence</a>
<ul class="sectlevel2">
<li><a href="#_参考资料">参考资料</a></li>
</ul>
</li>
</ul>
</div>
</div>
<div id="content">
<div class="sect1">
<h2 id="_334_increasing_triplet_subsequence"><a class="anchor" href="#_334_increasing_triplet_subsequence"></a>334. Increasing Triplet Subsequence</h2>
<div class="sectionbody">
<div class="paragraph">
<p><a href="https://leetcode.com/problems/increasing-triplet-subsequence/">LeetCode - Increasing Triplet Subsequence</a></p>
</div>
<div class="paragraph">
<p>这道题可以使用 <a href="0300-longest-increasing-subsequence.html">300. Longest Increasing Subsequence</a> 的思路来解决。具体思路分析可以看 <a href="https://leetcode-cn.com/problems/longest-increasing-subsequence/solution/zui-chang-shang-sheng-zi-xu-lie-dong-tai-gui-hua-2/">最长上升子序列（动态规划 + 二分查找，清晰图解） - 最长上升子序列 - 力扣（LeetCode）</a>。</p>
</div>
<div class="paragraph">
<p>更优的解题思路：</p>
</div>
<div class="paragraph">
<p>首先，新建两个变量 small 和 mid ，分别用来保存题目要我们求的长度为 3 的递增子序列的最小值和中间值。</p>
</div>
<div class="paragraph">
<p>接着，我们遍历数组，每遇到一个数字，我们将它和 small 和 mid 相比，若小于等于 small ，则替换 small；否则，若小于等于 mid，则替换 mid；否则，若大于 mid，则说明我们找到了长度为 3 的递增数组！</p>
</div>
<div class="paragraph">
<p>上面的求解过程中有个问题：当已经找到了长度为 2 的递增序列，这时又来了一个比 small 还小的数字，为什么可以直接替换 small 呢，这样 small 和 mid 在原数组中并不是按照索引递增的关系呀？</p>
</div>
<div class="paragraph">
<p>Trick 就在这里了！假如当前的 small 和 mid 为 [3, 5]，这时又来了个 1。假如我们不将 small 替换为 1，那么，当下一个数字是 2，后面再接上一个 3 的时候，我们就没有办法发现这个 [1,2,3] 的递增数组了！也就是说，我们替换最小值，是为了后续能够更好地更新中间值！</p>
</div>
<div class="paragraph">
<p>另外，即使我们更新了 small ，这个 small 在 mid 后面，没有严格遵守递增顺序，但它隐含着的真相是，<strong>有一个比 small 大比 mid 小的前·最小值出现在 mid 之前。因此，当后续出现比 mid 大的值的时候，我们一样可以通过当前 small 和 mid 推断的确存在着长度为 3 的递增序列。</strong> 所以，这样的替换并不会干扰我们后续的计算！</p>
</div>
<div class="sect2">
<h3 id="_参考资料"><a class="anchor" href="#_参考资料"></a>参考资料</h3>
<div class="olist arabic">
<ol class="arabic">
<li>
<p><a href="https://leetcode-cn.com/problems/increasing-triplet-subsequence/solution/c-xian-xing-shi-jian-fu-za-du-xiang-xi-jie-xi-da-b/">C++ 线性时间复杂度详细解析，打败 98% - 递增的三元子序列 - 力扣（LeetCode）</a></p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Given an unsorted array return whether an increasing subsequence of length 3 exists or not in the array.</p>
</div>
<div class="paragraph">
<p>Formally the function should:</p>
</div>
<div class="paragraph">
<p>&lt;blockquote&gt;Return true if there exists _i, j, k _</p>
</div>
<div class="paragraph">
<p>such that <em>arr[i]</em> &lt; <em>arr[j]</em> &lt; <em>arr[k]</em> given 0 ≤ <em>i</em> &lt; <em>j</em> &lt; <em>k</em> ≤ <em>n</em>-1 else return false.&lt;/blockquote&gt;</p>
</div>
<div class="paragraph">
<p>*Note: *Your algorithm should run in O(<em>n</em>) time complexity and O(<em>1</em>) space complexity.</p>
</div>
<div class="paragraph">
<p><strong>Example 1:</strong></p>
</div>
<div class="listingblock">
<div class="content">
<pre><strong>Input:</strong> [1,2,3,4,5]
<strong>Output:</strong> true</pre>
</div>
</div>
<div class="paragraph">
<p><strong>Example 2:</strong></p>
</div>
<div class="listingblock">
<div class="content">
<pre><strong>Input:</strong> [5,4,3,2,1]
<strong>Output:</strong> false</pre>
</div>
</div>
<div id="src-0334" class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-{java_source_attr}" data-lang="{java_source_attr}">package com.diguage.algorithm.leetcode;

import java.util.Arrays;
import java.util.Objects;

/**
 * = 334. Increasing Triplet Subsequence
 *
 * Given an unsorted array return whether an increasing subsequence of length 3 exists or not in the array.
 *
 * Formally the function should:
 *
 * ****
 * Return true if there exists i, j, k
 * such that arr[i] &lt; arr[j] &lt; arr[k] given 0 ≤ i &lt; j &lt; k ≤ n-1 else return false.
 * ****
 *
 * *Note:* Your algorithm should run in O(n) time complexity and O(1) space complexity.
 *
 * .Example 1:
 * [source]
 * ----
 * Input: [1,2,3,4,5]
 * Output: true
 * ----
 *
 * .Example 2:
 * [source]
 * ----
 * Input: [5,4,3,2,1]
 * Output: false
 * ----
 *
 * @author D瓜哥, https://www.diguage.com/
 * @since 2020-01-27 14:26
 */
public class _0334_IncreasingTripletSubsequence {
    /**
     * Runtime: 0 ms, faster than 100.00% of Java online submissions for Increasing Triplet Subsequence.
     *
     * Memory Usage: 39.3 MB, less than 93.02% of Java online submissions for Increasing Triplet Subsequence.
     */
    public boolean increasingTriplet(int[] nums) {
        if (Objects.isNull(nums) || nums.length &lt; 3) {
            return false;
        }
        int small = Integer.MAX_VALUE;
        int mid = Integer.MAX_VALUE;
        for (int i = 0; i &lt; nums.length; i++) {
            int num = nums[i];
            if (num &lt;= small) {
                small = num;
            } else if (num &lt;= mid) {
                mid = num;
            } else if (mid &lt; num) {
                return true;
            }
        }
        return false;
    }

    /**
     * Runtime: 152 ms, faster than 5.23% of Java online submissions for Increasing Triplet Subsequence.
     *
     * Memory Usage: 40.4 MB, less than 6.98% of Java online submissions for Increasing Triplet Subsequence.
     */
    public boolean increasingTripletDp(int[] nums) {
        if (Objects.isNull(nums) || nums.length &lt; 3) {
            return false;
        }
        int[] dp = new int[nums.length];
        Arrays.fill(dp, 1);
        int max = 1;
        for (int i = 1; i &lt; nums.length; i++) {
            for (int j = 0; j &lt; i; j++) {
                if (nums[j] &lt; nums[i]) {
                    dp[i] = Math.max(dp[i], dp[j] + 1);
                }
            }
            max = Math.max(max, dp[i]);
            if (max &gt;= 3) {
                return true;
            }
        }
        return false;
    }

    public static void main(String[] args) {
        _0334_IncreasingTripletSubsequence solution = new _0334_IncreasingTripletSubsequence();

        int[] n5 = {1, 1, -2, 6};
        boolean r5 = solution.increasingTriplet(n5);
        System.out.println(!r5);


        int[] n4 = {2, 4, -2, -3};
        boolean r4 = solution.increasingTriplet(n4);
        System.out.println(!r4);

        int[] n3 = {1, 2, 3, 1, 2, 1};
        boolean r3 = solution.increasingTriplet(n3);
        System.out.println(r3);

        int[] n1 = {1, 2, 3, 4, 5};
        boolean r1 = solution.increasingTriplet(n1);
        System.out.println(r1);

        int[] n2 = {5, 4, 3, 2, 1};
        boolean r2 = solution.increasingTriplet(n2);
        System.out.println(!r2);
    }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div id="footer">
<div id="footer-text">
Last updated 2020-02-13 11:39:08 +0800
</div>
</div>
</body>
</html>