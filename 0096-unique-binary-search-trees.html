<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="generator" content="Asciidoctor 2.0.10">
<title>96. Unique Binary Search Trees</title>
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:300,300italic,400,400italic,600,600italic%7CNoto+Serif:400,400italic,700,700italic%7CDroid+Sans+Mono:400,700">
<link rel="stylesheet" href="assets/css/asciidoctor.css">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">
</head>
<body class="book toc2 toc-left">
<div id="header">
<div id="toc" class="toc2">
<div id="toctitle">Table of Contents</div>
<ul class="sectlevel1">
<li><a href="#_96_unique_binary_search_trees">96. Unique Binary Search Trees</a>
<ul class="sectlevel2">
<li><a href="#_参考资料">参考资料</a></li>
</ul>
</li>
</ul>
</div>
</div>
<div id="content">
<div class="sect1">
<h2 id="_96_unique_binary_search_trees"><a class="anchor" href="#_96_unique_binary_search_trees"></a>96. Unique Binary Search Trees</h2>
<div class="sectionbody">
<div class="paragraph">
<p><a href="https://leetcode.com/problems/unique-binary-search-trees/">LeetCode - Unique Binary Search Trees</a></p>
</div>
<div class="paragraph">
<p>Given <em>n</em>, how many structurally unique <strong>BST&#8217;s</strong> (binary search trees) that store values <em>1 &#8230;&#8203; n</em>?</p>
</div>
<div class="listingblock">
<div class="title">Example:</div>
<div class="content">
<pre class="highlight"><code>Input: 3
Output: 5
Explanation:
Given n = 3, there are a total of 5 unique BST's:

   1         3     3      2      1
    \       /     /      / \      \
     3     2     1      1   3      2
    /     /       \                 \
   2     1         2                 3</code></pre>
</div>
</div>
<div class="paragraph">
<p>给定一个有序序列 <code>1 &#8230;&#8203; n</code>，为了根据序列构建一棵二叉搜索树。我们可以遍历每个数字 <code>i</code>，将该数字作为树根，<code>1 &#8230;&#8203; (i-1)</code> 序列将成为左子树，<code>(i+1) &#8230;&#8203; n</code> 序列将成为右子树。于是，我们可以递归地从子序列构建子树。</p>
</div>
<div class="paragraph">
<p>在上述方法中，由于根各自不同，每棵二叉树都保证是独特的。</p>
</div>
<div class="paragraph">
<p>可见，问题可以分解成规模较小的子问题。因此，我们可以存储并复用子问题的解，而不是递归的（也重复的）解决这些子问题，这就是动态规划法。</p>
</div>
<div class="paragraph">
<p>给定序列 <code>1 &#8230;&#8203; n</code>，我们选出数字 <code>i</code> 作为根，则对于根 <code>i</code> 的不同二叉搜索树数量 \(F(i, n)\)，是左右子树个数的笛卡尔积，如下图所示:</p>
</div>
<div class="imageblock">
<div class="content">
<img src="./images/0096-1.png" alt="0096 1">
</div>
</div>
<div class="paragraph">
<p>没想到这里还埋了一个数学知识：Catalan number：</p>
</div>
<div class="stemblock">
<div class="content">
\$C_{0}=1 \quad \text { and } \quad C_{n+1}=\sum_{i=0}^{n} C_{i} C_{n-i} \quad \text { for } n \geq 0\$<br>
<br>
\$C_{0}=1, \quad C_{n+1}=\frac{2(2 n+1)}{n+2} C_{n}\$
</div>
</div>
<div class="paragraph">
<p>附加题：参考资料显示，关于 Catalan number 有好多好玩的东西可以把玩。查资料把玩把玩。</p>
</div>
<div class="sect2">
<h3 id="_参考资料"><a class="anchor" href="#_参考资料"></a>参考资料</h3>
<div class="olist arabic">
<ol class="arabic">
<li>
<p><a href="https://en.wikipedia.org/wiki/Catalan_number">Catalan number - Wikipedia</a></p>
</li>
<li>
<p><a href="https://leetcode-cn.com/problems/unique-binary-search-trees/solution/bu-tong-de-er-cha-sou-suo-shu-by-leetcode/">不同的二叉搜索树 - 不同的二叉搜索树 - 力扣（LeetCode）</a></p>
</li>
<li>
<p><a href="https://blog.csdn.net/Hackbuteer1/article/details/7450250">Catalan数——卡特兰数_Hackbuteer1的专栏-CSDN博客</a></p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Given <em>n</em>, how many structurally unique <strong>BST&#8217;s</strong> (binary search trees) that store values 1 &#8230;&#8203; <em>n</em>?</p>
</div>
<div class="paragraph">
<p><strong>Example:</strong></p>
</div>
<div class="listingblock">
<div class="content">
<pre><strong>Input:</strong> 3
<strong>Output:</strong> 5
*Explanation:
*Given <em>n</em> = 3, there are a total of 5 unique BST's:

   1         3     3      2      1
    \       /     /      / \      \
     3     2     1      1   3      2
    /     /       \                 \
   2     1         2                 3</pre>
</div>
</div>
<div id="src-0096" class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-{java_source_attr}" data-lang="{java_source_attr}">package com.diguage.algorithm.leetcode;

/**
 * = 96. Unique Binary Search Trees
 *
 * https://leetcode.com/problems/unique-binary-search-trees/[Unique Binary Search Trees - LeetCode]
 *
 * @author D瓜哥, https://www.diguage.com/
 * @since 2020-01-27 22:14
 */
public class _0096_UniqueBinarySearchTrees {

    /**
     * Runtime: 0 ms, faster than 100.00% of Java online submissions for Unique Binary Search Trees.
     * Memory Usage: 38.2 MB, less than 5.55% of Java online submissions for Unique Binary Search Trees.
     *
     * Copy from: https://leetcode-cn.com/problems/unique-binary-search-trees/solution/bu-tong-de-er-cha-sou-suo-shu-by-leetcode/[不同的二叉搜索树 - 不同的二叉搜索树 - 力扣（LeetCode）]
     */
    public int numTreesCatalanNumber(int n) {
        long C = 1;
        for (int i = 0; i &lt; n; i++) {
            C = C * 2 * (2 * i + 1) / (i + 2);
        }
        return (int) C;
    }

    /**
     * Runtime: 0 ms, faster than 100.00% of Java online submissions for Unique Binary Search Trees.
     * Memory Usage: 36 MB, less than 5.55% of Java online submissions for Unique Binary Search Trees.
     *
     * Copy from: https://leetcode-cn.com/problems/unique-binary-search-trees/solution/bu-tong-de-er-cha-sou-suo-shu-by-leetcode/[不同的二叉搜索树 - 不同的二叉搜索树 - 力扣（LeetCode）]
     */
    public int numTrees(int n) {
        int[] g = new int[n + 1];
        g[0] = 1;
        g[1] = 1;
        for (int i = 2; i &lt;= n; i++) {
            for (int j = 1; j &lt;= i; j++) {
                g[i] += g[j - 1] * g[i - j];
            }
        }
        return g[n];
    }

    public static void main(String[] args) {
        _0096_UniqueBinarySearchTrees solution = new _0096_UniqueBinarySearchTrees();
        int r1 = solution.numTrees(3);
        System.out.println((r1 == 5) + " : " + r1);
    }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div id="footer">
<div id="footer-text">
Last updated 2020-02-13 11:39:08 +0800
</div>
</div>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  messageStyle: "none",
  tex2jax: {
    inlineMath: [["\\(", "\\)"]],
    displayMath: [["\\[", "\\]"]],
    ignoreClass: "nostem|nolatexmath"
  },
  asciimath2jax: {
    delimiters: [["\\$", "\\$"]],
    ignoreClass: "nostem|noasciimath"
  },
  TeX: { equationNumbers: { autoNumber: "none" } }
})
MathJax.Hub.Register.StartupHook("AsciiMath Jax Ready", function () {
  MathJax.InputJax.AsciiMath.postfilterHooks.Add(function (data, node) {
    if ((node = data.script.parentNode) && (node = node.parentNode) && node.classList.contains('stemblock')) {
      data.math.root.display = "block"
    }
    return data
  })
})
</script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_HTMLorMML"></script>
</body>
</html>