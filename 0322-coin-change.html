<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="generator" content="Asciidoctor 2.0.10">
<title>322. Coin Change</title>
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:300,300italic,400,400italic,600,600italic%7CNoto+Serif:400,400italic,700,700italic%7CDroid+Sans+Mono:400,700">
<link rel="stylesheet" href="assets/css/asciidoctor.css">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">
</head>
<body class="book toc2 toc-left">
<div id="header">
<div id="toc" class="toc2">
<div id="toctitle">Table of Contents</div>
<ul class="sectlevel1">
<li><a href="#_322_coin_change">322. Coin Change</a></li>
</ul>
</div>
</div>
<div id="content">
<div class="sect1">
<h2 id="_322_coin_change"><a class="anchor" href="#_322_coin_change"></a>322. Coin Change</h2>
<div class="sectionbody">
<div class="paragraph">
<p><a href="https://leetcode.com/problems/coin-change/">LeetCode - Coin Change</a></p>
</div>
<div class="imageblock">
<div class="content">
<img src="./images/0322-1.png" alt="0322 1">
</div>
</div>
<div class="paragraph">
<p>思考题：</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>如何把动态规划代码写得更简洁一些？</p>
</li>
<li>
<p>如何使用自底向上方法来实现一遍动态规划？</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>You are given coins of different denominations and a total amount of money <em>amount</em>. Write a function to compute the fewest number of coins that you need to make up that amount. If that amount of money cannot be made up by any combination of the coins, return <code>-1</code>.</p>
</div>
<div class="paragraph">
<p><strong>Example 1:</strong></p>
</div>
<div class="listingblock">
<div class="content">
<pre><strong>Input:</strong> coins = <code>[1, 2, 5]</code>, amount = <code>11</code>
<strong>Output:</strong> <code>3</code>
<strong>Explanation:</strong> 11 = 5 + 5 + 1</pre>
</div>
</div>
<div class="paragraph">
<p><strong>Example 2:</strong></p>
</div>
<div class="listingblock">
<div class="content">
<pre><strong>Input:</strong> coins = <code>[2]</code>, amount = <code>3</code>
<strong>Output:</strong> -1</pre>
</div>
</div>
<div class="paragraph">
<p><strong>Note</strong>:</p>
</div>
<div class="paragraph">
<p>You may assume that you have an infinite number of each kind of coin.</p>
</div>
<div id="src-0322" class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-{java_source_attr}" data-lang="{java_source_attr}">package com.diguage.algorithm.leetcode;

import java.util.*;

/**
 * = 322. Coin Change
 *
 * https://leetcode.com/problems/coin-change/[Coin Change - LeetCode]
 *
 * You are given coins of different denominations and a total amount of money amount. Write a function to compute the fewest number of coins that you need to make up that amount. If that amount of money cannot be made up by any combination of the coins, return `-1`.
 *
 * .Example 2:
 * [source]
 * ----
 * Input: coins = [1, 2, 5], amount = 11
 * Output: 3
 * Explanation: 11 = 5 + 5 + 1
 * ----
 *
 * .Example 2:
 * [source]
 * ----
 * Input: coins = [2], amount = 3
 * Output: -1
 * ----
 *
 * *Note:*
 *
 * You may assume that you have an infinite number of each kind of coin.
 *
 * @author D瓜哥, https://www.diguage.com/
 * @since 2020-01-26 22:16
 */
public class _0322_CoinChange {

    /**
     * Runtime: 91 ms, faster than 6.13% of Java online submissions for Coin Change.
     *
     * Memory Usage: 42.7 MB, less than 5.33% of Java online submissions for Coin Change.
     *
     * Copy from: https://leetcode.com/problems/coin-change/solution/[Coin Change solution - LeetCode]
     */
    public int coinChange(int[] coins, int amount) {
        return coinChange(coins, amount, new int[amount]);
    }

    private int coinChange(int[] coins, int current, int[] count) {
        if (current &lt; 0) {
            return -1;
        }
        if (current == 0) {
            return 0;
        }
        if (count[current - 1] != 0) {
            return count[current - 1];
        }
        int min = Integer.MAX_VALUE;
        for (int coin : coins) {
            int res = coinChange(coins, current - coin, count);
            if (0 &lt;= res &amp;&amp; res &lt; min) {
                min = res + 1;
            }
        }
        count[current - 1] = (min == Integer.MAX_VALUE) ? -1 : min;
        return count[current - 1];
    }

    /**
     * Runtime: 427 ms, faster than 5.00% of Java online submissions for Coin Change.
     *
     * Memory Usage: 115.5 MB, less than 5.33% of Java online submissions for Coin Change.
     */
    public int coinChangeDpWithMemo(int[] coins, int amount) {
        int count = dpWithMemo(coins, new HashMap&lt;&gt;(), amount, amount);
        if (count &gt; amount) {
            return -1;
        }
        return count;
    }

    public int dpWithMemo(int[] coins, Map&lt;Integer, Integer&gt; memo, int amount, int current) {
        if (current == 0) {
            return 0;
        }
        if (current &lt; 0) {
            return amount;
        }

        List&lt;Integer&gt; counts = new ArrayList&lt;&gt;();
        for (int coin : coins) {
            int newCoin = current - coin;
            int count;
            if (memo.containsKey(newCoin)) {
                count = memo.get(newCoin);
            } else {
                count = dpWithMemo(coins, memo, amount, newCoin) + 1;
                memo.put(newCoin, count);
            }
            counts.add(count);
        }
        return Collections.min(counts);
    }

    /**
     * Time Limit Exceeded
     */
    public int coinChangeDp(int[] coins, int amount) {
        int count = dp(coins, amount, amount);
        if (count &gt; amount) {
            return -1;
        }
        return count;
    }

    private int dp(int[] coins, int amount, int current) {
        if (current == 0) {
            return 0;
        }
        if (current &lt; 0) {
            return amount;
        }

        List&lt;Integer&gt; counts = new ArrayList&lt;&gt;();
        for (int coin : coins) {
            counts.add(dp(coins, amount, current - coin) + 1);
        }
        return Collections.min(counts);
    }

    public static void main(String[] args) {
        _0322_CoinChange solution = new _0322_CoinChange();
        int[] c1 = {1, 2, 5};
        int r1 = solution.coinChange(c1, 11);
        System.out.println((r1 == 3) + " : " + r1);

        int[] c2 = {2};
        int r2 = solution.coinChange(c2, 3);
        System.out.println((r2 == -1) + " : " + r2);
    }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
<div id="footer">
<div id="footer-text">
Last updated 2020-02-13 11:39:08 +0800
</div>
</div>
</body>
</html>